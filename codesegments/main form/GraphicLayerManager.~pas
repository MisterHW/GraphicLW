unit GraphicLayerManager;

interface
uses
   Windows, Messages, Sysutils,Classes, Controls, Types, Graphics, JPeg, PNGImage, Forms, math,
   GLWDef, LayerSelectDlg, NotificationNode, VisualOverlayClass, FileSystemWatch, ShellAPI, OpenSystem,
   MultiFunctionalInputDialog;
   

  Type TGLMZoomMode     = ( zmExponential,
                            zmPixelwise,
                            zmLinear,
                            zmPresetSteps,
                            zmFixTo100Percent);

  Type TGLMHalftoneMode = ( htmBlocks,
                            htmHalftone);


  Type TGraphicLayerManager = class(TObject)
    constructor Create(Target: TForm);
    destructor Destroy; override;

  private
    parent: TForm;
    buffer: TBitmap;
    frmDockMode: TDockMode;
    frm: TLayerSelectDlg;  // only one dialog window at a time. It's
                           // better for transparence because they all look the same!
    DialogStarter:TObject; // create privilege for starter to terminate dialog while it is running

    _zoom: Single;
    _ZoomMode : TGLMZoomMode;
    _HalftoneMode: TGLMHalftoneMode;
    _pos: TPoint;
    _LayerSelectionID: integer;
    _surpressrepaint: Boolean;

    VisualOverlays : Array Of TVisualOverlay;
    EventLinkedVisualUID: longint;
    DownEventShiftState: TShiftState;

    CanMoveOrigin : Boolean; // origin can be moved if the mouse actions are not forwarded
    StartPosition : TPoint;
    OldOrigin : TPoint;

    PreviewHooks: Array of TGLMPreviewHookCallback;
    TerminatedInMessageLoop: Boolean;
    procedure SetZoom(newzoom: Single);
    procedure SetOrigin(newpos: TPoint);
    procedure CallPreviewHooks(LayerID: integer; buf: TBitmap; area: TRect);
    procedure TempFileChangeNotify(Sender:TObject);

    procedure ZoomByDelta(ticks: longint);
    procedure SetZoomMode(newmode:TGLMZoomMode);
    procedure SetHalftoneMode(newmode:TGLMHalftoneMode);
  public
    zoompoint: TPoint;
    GlobalMetaContent: TMetaData;
    Layers: Array of TSingleLayer;
    OnCustomPostRender : TNotifyEvent; // self param = buffer (workaround)
    OnAddLayer: TNotifyEvent;
    OnCurrentLayerChange: TNotifyEvent;
    CurrentLayer: longint;   // only used for OnCurrentLayerChange event
    OnLayerChanges: TNotificationNode;
    OnMiddleMouseButtonClick : TMouseClickEvent;
    OnDblClick: TNotifyEvent;

    property  ZoomFactor : Single read _zoom write SetZoom;
    property  Origin : TPoint read _pos write SetOrigin;
    property  imagebuffer : TBitmap read buffer;
    property  LayerSelectionID : integer read _LayerSelectionID;
    property  ZoomMode: TGLMZoomMode read _ZoomMode write SetZoomMode;

    procedure ClientPaint(Sender: TObject);
    procedure surpressrepaint;
    function  ScreenToGlobalCoord(Cursor: TPoint):TPoint;
    function  GlobalCoordToScreen(Cursor: TPoint):TPoint;

    function  LayerByID(LayerID: longint):integer;
    function  NewLayerLoadFromFile(left, top: Longint; filename: String): integer;
    function  SaveLayerToFile(LayerID: longint; filename: string; Extension: string): BOOLEAN;
    function  NewLayer(bounds: TRect; Color:TColor): integer;
    procedure DeleteLayer(idx: integer);
    procedure FocusLayer(LayerIndex: integer);

    function  InsertFilter(Layer: integer;
                _FilterID: Cardinal;_FilterData:Pointer; _DataSize: int64;
                StreamObject: TMemoryStream = nil): integer;
    procedure RemoveFilter(Layer: integer; index: integer);
    procedure RemoveAllFilters(Layer:integer; ApplyChanges: Boolean = false);

    function  InsertPreviewHook(CallBack: TGLMPreviewHookCallback): boolean;
    function  RemovePreviewHook(CallBack: TGLMPreviewHookCallback): boolean;
    procedure RemoveAllPreviewHooks;

    function ExecuteLayerSelectionDialog(PreselectedLayerID: integer = -1;
                AllowMultiSelection: Boolean = false; TabKeyExit: Boolean = false;
                Sender:TObject = nil) : Boolean;
    procedure UpdateLayerSelectionDialog(Sender:TObject);
    function  TerminateLayerSelectionDialog(Sender:TObject = nil): Boolean;


    procedure UpdateMaskLayerUsageInformation;

    procedure InsertVisualOverlayObject(newobj: TVisualOverlay);
    function  RemoveVisualOverlayObject(obj: TVisualOverlay):TVisualOverlay; overload;
    function  RemoveVisualOverlayObject(UID: longint):TVisualOverlay; overload;
    function  GetVisualOverlayObjectByID(UID: longint): TVisualOverlay;
    function  GetVisualOverlayUIDByPos(pos: TPoint;Shift: TShiftState;
                 Button:TMouseButton = mbLeft): longint;
    procedure UpdateVisualOverlays(NewScreenArea: TRect);
    procedure ClientPaintLocally(Sender:TObject); // used for some classes like VisualOverlay

    procedure OnParentMouseDown(Sender: TObject; Button: TMouseButton;
                  Shift: TShiftState; X, Y: Integer);
    procedure OnParentMouseMove(Sender: TObject;  Shift: TShiftState; X, Y: Integer);
    procedure OnParentMouseUp(Sender: TObject; Button: TMouseButton;
                  Shift: TShiftState; X, Y: Integer);
    procedure OnParentMouseWheel(Sender: TObject; Shift: TShiftState;
                  WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
    procedure OnParentKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure OnParentKeyPress(Sender:TObject; var Key: Char);
    procedure OnParentKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure OnParentDblClick(Sender: TObject);

    procedure CallExternalEditor(LayerID: Longint; filename: string; paramstring: string);
    procedure ReleaseExternalEditor(LayerID: Longint);

    procedure ResizeBuffer(BoundsRect: TRect);
    procedure OnParentResize(Sender:TObject);

    procedure ExecutePresetsDialog(Sender:TObject);
  end;




implementation




uses
  GLMFunctionality;   // core functions


const
  ZoomPresetArray : Array[0..59] of single = (
    5,
    6,
    7,
    7.5,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    16,
    19,
    20,
    22,
    25,
    27,
    29,
    33,
    36,
    39,
    42,
    46,
    50,
    55,
    60,
    66,
    75,
    83,
    90,
    100,
    110,
    120,
    133,
    150,
    165,
    180,
    200,
    220,
    240,
    260,
    280,
    300,
    333,
    366,
    400,
    450,
    500,
    550,
    600,
    666,
    720,
    800,
    900,
    1000,
    1100,
    1200,
    1333,
    1500,
    1600 );



constructor TGraphicLayerManager.Create(Target: TForm);
    var
      mid: integer;
begin
      parent := Target;
      _zoom := 1;
      _pos := Point(0,0);
      _surpressrepaint := false;
      OnCustomPostRender := nil;

      buffer := TBitmap.Create;
      buffer.Canvas.Brush.Color := clgray;
      buffer.PixelFormat := pf24bit;
      mid := Screen.MonitorFromWindow(Target.Handle).MonitorNum;
      buffer.Width := Screen.Monitors[mid].Width;
      buffer.Height := Screen.Monitors[mid].Height;
      setlength(PreviewHooks,0);

      OnLayerChanges:= TNotificationNode.Create;
      TerminatedInMessageLoop := false;

      EventLinkedVisualUID := -1;

      frmDockMode := dm_bottom; // dm_none; // or read from config file
      frm := nil;

      _ZoomMode := zmPresetSteps; //zmExponential;

      GlobalMetaContent:= TMetaData.Create;
end;




destructor TGraphicLayerManager.Destroy;
    var
      i: integer;
begin
      GlobalMetaContent.Destroy;

      for i := 0 to length(Layers)-1 do
        if assigned(Layers[i].data) then Layers[i].data.Destroy;
      setlengtH(Layers,0);

      for i := 0 to length(VisualOverlays)-1 do
        self.VisualOverlays[i].Destroy;
      setlength(VisualOverlays,0);

      buffer.Destroy;
      OnLayerChanges.Destroy;
      inherited;
end;




procedure TGraphicLayerManager.SetZoom(newzoom: Single);
begin
      newzoom := constrain(0.05,16,newzoom); // zoom range = 5% - 1600%
      self._pos.X := round( (self._pos.X - self.zoompoint.X) * (newzoom / _zoom) + self.zoompoint.X);
      self._pos.Y := round( (self._pos.Y - self.zoompoint.Y) * (newzoom / _zoom) + self.zoompoint.Y);
      self._zoom := newzoom;
      self.ClientPaint(nil);
end;



procedure TGraphicLayerManager.ClientPaint(Sender: TObject);
    var
      LayerDataRect, SourceDataRect, Intersection, ClientRect: TFltRect;
      i: integer;
      zsf : single;
begin
      // check if skip flag is set
      if self._surpressrepaint then
      begin
         _surpressrepaint:= false;
         exit;
      end;

      // reset buffer parameters
      buffer.Canvas.Brush.Style := bssolid;
      buffer.Canvas.Brush.Color := parent.Color;
      buffer.Canvas.FillRect(Parent.ClientRect);

      // set buffer StretchBlt mode
      if self._HalftoneMode = htmHalftone then
      begin
        // CreateHalftonePalette(buffer.Canvas.Handle);
        SetStretchBltMode(buffer.canvas.Handle, STRETCH_HALFTONE);
        SetBrushOrgEx(buffer.Canvas.Handle,0,0,nil); // avoid brush misalignment
      end
      else
      begin
        SetStretchBltMode(buffer.canvas.Handle, STRETCH_DELETESCANS);
        SetBrushOrgEx(buffer.Canvas.Handle,0,0,nil); // avoid brush misalignment
      end;

      // draw layers
      for i := 0 to Length(Layers)-1 do
      begin
        zsf := _zoom * Layers[i].InternalScaling;  // zoom scale factor
        LayerDataRect.Left   := round(  Layers[i].Position.X                        * zsf + _pos.X);
        LayerDataRect.Top    := round(  Layers[i].Position.Y                        * zsf + _pos.Y);
        LayerDataRect.Right  := round( (Layers[i].Position.X+Layers[i].data.Width ) * zsf + _pos.X );
        LayerDataRect.Bottom := round( (Layers[i].Position.Y+Layers[i].data.Height) * zsf + _pos.Y );

        ClientRect   := RectToFltRect(Parent.ClientRect);
        Intersection := IntersectionRect(LayerDataRect,ClientRect);

        if not EmptyIntersection(FltRectToRect(Intersection)) then
        begin
           SourceDataRect.Left   := ( (Intersection.Left   - LayerDataRect.Left) /zsf );
           SourceDataRect.Top    := ( (Intersection.Top    - LayerDataRect.Top)  /zsf );
           SourceDataRect.Right  := ( (Intersection.Right  - LayerDataRect.Left )/zsf );
           SourceDataRect.Bottom := ( (Intersection.Bottom - LayerDataRect.Top)  /zsf );

           if Layers[i].visible then
           begin
             if not Layers[i].suppressed then
               StretchCopyRect(Layers[i].data,buffer, SourceDataRect, Intersection); // improved method
             self.CallPreviewHooks(Layers[i].LayerID,buffer,FltRectToRect(Intersection));
           end;
        end;
      end;

      // call overlay object rendering procedures
      for i := 0 to Length(self.VisualOverlays)-1 do
        if self.VisualOverlays[i].Visible then
          self.VisualOverlays[i].Paint(buffer,self.Origin,self._zoom);

      // perform post-rendering, if assigned
      if assigned(OnCustomPostRender) then OnCustomPostRender(self.buffer);

      // blit buffer
      // it will be necessary to implement local updating that differs from ClientPaintLocally by
      // executing the rendering code above, followed by a cropped BitBlt to increase performance !!!
      // restricting the rendering of overlays and layers would cause too much trouble to be
      // a serious goal for performance tweaking. Get back to that when multiple alphablended layers
      // have to be redrawn over and over again... but not today.
      //
      Windows.BitBlt(parent.Canvas.Handle,
          0,0,buffer.Width,buffer.Height,
          buffer.Canvas.Handle,0,0,
          SRCCOPY);
end;




function TGraphicLayerManager.NewLayerLoadFromFile(left, top: Longint; filename: String): integer;
    var
      tempdata: TBitmap;
      jpg : TJPegImage;
      png: TPNGObject;
      Stream:TStream;
begin
      tempdata := nil;
      result := -1;

      if not fileexists(filename) then exit;

      if lowercase(ExtractFileExt(filename)) = '.png' then
      begin
        tempdata := TBitmap.Create;
        tempdata.PixelFormat := pf24bit;
        png := TPNGObject.Create;
        png.LoadFromFile(filename);
        tempdata.PixelFormat := pf24bit;
        tempdata.Width := png.Width;
        tempdata.Height := png.Height;
        tempdata.Canvas.Draw(0,0,png);
        png.Destroy;
      end;

      if lowercase(ExtractFileExt(filename)) = '.jpg' then
      begin
        tempdata := TBitmap.Create;
        tempdata.PixelFormat := pf24bit;
        jpg := TJPegImage.Create;
        jpg.LoadFromFile(filename);
        tempdata.PixelFormat := pf24bit;
        tempdata.Width := jpg.Width;
        tempdata.Height := jpg.Height;
        tempdata.Canvas.Draw(0,0,jpg);
        jpg.Destroy;
      end;

      if lowercase(ExtractFileExt(filename)) = '.bmp' then
      begin
        Stream := TFileStream.Create(filename, fmOpenRead or fmShareDenyNone);
        try
          tempdata := TBitmap.Create;
          tempdata.LoadFromStream(Stream);
          tempdata.PixelFormat := pf24bit;
          { it was necessary to patch up the Delphi7 VCL implementation
            as shown below:

            Graphics.pas :: procedure TBitmap.ReadDIB(...);
            [...]
            // (h.w.2011-01-14): I noticed that the BitsMem size returned by
            // the system routine CreateDIBSection(...) is the exact
            // amount of memory needed for the image so any accidental padding
            // after the image data block will cause an unhandled stream read
            // error because ImageSize is too large.
            // for uncompressed images, it is easy to recalculate the size
            with BitmapInfo^.bmiHeader do
            if (biCompression = BI_RGB) then
            begin
              ImageSize := ((( biWidth * biBitCount + 7 ) div 8 + 3 ) div 4 ) * 4
                             * biHeight;
            end;
            Stream.ReadBuffer(BitsMem^, ImageSize);
            [...]

            }
        except
          tempdata.Destroy;
          tempdata := nil;
        end;
        Stream.Free;
      end;

      if tempdata = nil then exit;

      setlength(self.Layers,length(self.Layers)+1);
      result := length(self.Layers)-1;
      with Layers[length(Layers)-1] do
      begin
          data := tempdata;
          Position.X := left;
          Position.Y := Top;
          InternalScaling := 1;
          Transparency := 1;
          LayerCaption := ExtractFileName(filename);
          visible := true;
          LayerID := Gettickcount;
          // mask := nil;
          MaskLayerID := -1;
          FilterHeapCursor := -1;
          setlength(FilterHeap,0);
          SelectableInDialog := true;
          IsSelectedInDialog := false;
          suppressed := false;
          externaleditwatcher := nil;
          LastModified := GetTickCount;
          meta := TMetaData.Create;
      end;
      If Assigned(OnAddLayer) then OnAddLayer(self);
      OnLayerChanges.SharedEvent(self); 
end;



function TGraphicLayerManager.NewLayer(bounds: TRect; Color:TColor): integer; // returns the new layer index
    var
      tempdata: TBitmap;
begin
        tempdata                    := TBitmap.Create;
        tempdata.PixelFormat        := pf24bit;
        tempdata.Canvas.Brush.Color := Color;
        tempdata.Width  := bounds.Right  - bounds.Left;
        tempdata.Height := bounds.Bottom - bounds.Top;

      setlength(self.Layers,length(self.Layers)+1);
      result := length(self.Layers)-1;
      with Layers[length(Layers)-1] do
      begin
          data := tempdata;
          Position.X := bounds.Left;
          Position.Y := bounds.top;
          InternalScaling := 1;
          Transparency := 1;
          LayerCaption := 'empty';
          visible := true;          
          LayerID := Gettickcount;
          // mask := nil;
          MaskLayerID := -1;
          FilterHeapCursor := -1;
          setlength(FilterHeap,0);
          SelectableInDialog := true;
          IsSelectedInDialog := false;
          suppressed := false;
          ExternalEditWatcher := nil;
          meta := TMetaData.Create;
      end;
      If Assigned(OnAddLayer) then OnAddLayer(self);
end;




procedure TGraphicLayerManager.SetOrigin(newpos: TPoint);
begin
      _pos := newpos;
      self.ClientPaint(nil);
end;




procedure TGraphicLayerManager.surpressrepaint;
begin
      self._surpressrepaint := true;
end;




function TGraphicLayerManager.ScreenToGlobalCoord(Cursor: TPoint):TPoint;
begin
      result.X := round((Cursor.X - _pos.X)/_zoom);
      result.Y := round((Cursor.Y - _pos.Y)/_zoom);
end;




function TGraphicLayerManager.GlobalCoordToScreen(Cursor: TPoint):TPoint;
begin
      Result.X := _pos.X + round( (Cursor.X) * _zoom );
      Result.Y := _pos.Y + round( (Cursor.Y) * _zoom );
end;




function TGraphicLayerManager.LayerByID(LayerID: longint):integer;
    var i: integer;
begin
      result := -1;
      for i := 0 to length(self.Layers)-1 do
      begin
        if Layers[i].LayerID  = LayerID then
        begin
          result := i;
          break;
        end;
      end;
end;




procedure TGraphicLayerManager.DeleteLayer(idx: integer);
    var
      k: integer;
      // fn : string;
begin
      if (idx < 0 ) or (idx > length(Layers)-1) then exit;

      self.ReleaseExternalEditor(Layers[idx].LayerID);

      if assigned(Layers[idx].data) then Layers[idx].data.Destroy;
      if assigned(Layers[idx].rawdata) then Layers[idx].rawdata.Destroy;

      Layers[idx].LayerCaption := ' - deleted - ';

      Layers[idx].meta.Destroy;
      Layers[idx].meta := nil;

      for k := idx to length(Layers)-2 do
      begin
        Layers[k] := Layers[k+1];
      end;

      setlength(Layers,length(Layers)-1);
      OnLayerChanges.SharedEvent(self);
end;




function TGraphicLayerManager.InsertFilter(Layer: integer;
                      _FilterID: Cardinal;_FilterData:Pointer; _DataSize: int64;
                      StreamObject: TMemoryStream = nil): integer;
    var
      i: integer;
begin
      result := -1;
      if (Layer < 0 ) or (Layer > length(Layers)-1) then exit;
      // if no filter has been applied yet, create raw image snapshot
      if Layers[Layer].FilterHeapCursor < 0 then
      begin
        Layers[Layer].rawdata := TBitmap.Create;
        Layers[Layer].rawdata.Width := Layers[Layer].data.Width;
        Layers[Layer].rawdata.Height := Layers[Layer].data.Height;
        Layers[Layer].rawdata.PixelFormat := Layers[Layer].data.PixelFormat;
        Layers[Layer].rawdata.Canvas.Draw(0,0,Layers[Layer].data);
      end;

      // shift all filters after cursor upwards by one
      setlength(Layers[Layer].FilterHeap,length(Layers[Layer].FilterHeap)+1);
      // Layers[Layer].FilterHeap[length(Layers[Layer].FilterHeap)-1] := AllocMem(SizeOf(TFilterInstruction));
      if (Layers[Layer].FilterHeapCursor > -1) then
        for  i := length(Layers[Layer].FilterHeap) -2 downto Layers[Layer].FilterHeapCursor + 1 do
        begin
          Layers[Layer].FilterHeap[i+1].FilterID := Layers[Layer].FilterHeap[i].FilterID;
          Layers[Layer].FilterHeap[i+1].FilterData := Layers[Layer].FilterHeap[i].FilterData;
          Layers[Layer].FilterHeap[i+1].FilterDataSize := Layers[Layer].FilterHeap[i].FilterDataSize;
        end;

      // insert new filter after cursor
      with Layers[Layer].FilterHeap[Layers[Layer].FilterHeapCursor + 1] do
      begin
        FilterID := _FilterID;
        FilterData := _FilterData;
        FilterDataSize := _DataSize;
        StreamObj := StreamObject;
      end;
      result := Layers[Layer].FilterHeapCursor + 1;
end;




procedure TGraphicLayerManager.RemoveFilter(Layer: integer; index: integer);
    var
      i: integer;
begin
      if (Layer < 0 ) or (Layer > length(Layers)-1) then exit;
      if (index < 0) or (index > length(Layers[layer].FilterHeap)-1) then exit;

      if assigned(Layers[Layer].FilterHeap[index].StreamObj)
          then begin Layers[Layer].FilterHeap[index].StreamObj.Free; end;
      if Layers[Layer].FilterHeap[index].FilterDataSize <> 0
        then FreeMem(Layers[Layer].FilterHeap[index].FilterData, Layers[Layer].FilterHeap[index].FilterDataSize);

      if index < length(Layers[Layer].FilterHeap) -1 then
      begin
        for  i := index to length(Layers[Layer].FilterHeap) -1   do
        begin
          Layers[Layer].FilterHeap[i].FilterID       := Layers[Layer].FilterHeap[i+1].FilterID;
          Layers[Layer].FilterHeap[i].FilterData     := Layers[Layer].FilterHeap[i+1].FilterData;
          Layers[Layer].FilterHeap[i].FilterDataSize := Layers[Layer].FilterHeap[i+1].FilterDataSize;
          Layers[Layer].FilterHeap[i].StreamObj      := Layers[Layer].FilterHeap[i+1].StreamObj;
        end;
      end;
      setlength(Layers[Layer].FilterHeap,length(Layers[Layer].FilterHeap)-1);
end;




procedure TGraphicLayerManager.RemoveAllFilters(Layer:integer; ApplyChanges: Boolean = false);
    var
      i: Integer;
begin
      if (Layer < 0 ) or (Layer > length(Layers)-1) then exit;

      if (not ApplyChanges) and assigned(Layers[layer].rawdata) then
         Layers[layer].data.Canvas.Draw(0,0,Layers[layer].rawdata);

      if assigned(Layers[layer].rawdata) then Layers[layer].rawdata.Free;

      for i := 0 to length(Layers[layer].FilterHeap)-1 do
      begin
        if Layers[layer].FilterHeap[i].FilterDataSize <> 0 then
          FreeMem(Layers[layer].FilterHeap[i].FilterData,Layers[layer].FilterHeap[i].FilterDataSize);

        if assigned(Layers[Layer].FilterHeap[i].StreamObj) then
        begin
          Layers[Layer].FilterHeap[i].StreamObj.Free; Layers[Layer].FilterHeap[i].StreamObj:=nil ;
        end;
      end;

      setlength(Layers[layer].FilterHeap,0);
      Layers[layer].FilterHeapCursor := -1;
end;




procedure TGraphicLayerManager.CallPreviewHooks(LayerID: integer; buf: TBitmap; area: TRect);
    var
      i: integer;
begin
      for i := 0 to length(PreviewHooks)-1 do
      begin
        try
          if assigned(PreviewHooks[i]) then PreviewHooks[i](LayerID,buf,area);
        except
        else
        end;
      end;
end;



function TGraphicLayerManager.InsertPreviewHook(CallBack: TGLMPreviewHookCallback): boolean;
begin
      result := false;
      RemovePreviewHook(CallBack); // do not insert hook twice
      if assigned(CallBack) then
      begin
        setlength(PreviewHooks,length(PreviewHooks)+1);
        PreviewHooks[length(PreviewHooks)-1] := Callback;
        result := true;
      end;
end;



function TGraphicLayerManager.RemovePreviewHook(CallBack: TGLMPreviewHookCallback): boolean;
    var
      i,j: integer;
begin
      result := false;
      for i := 0 to length(PreviewHooks)-1 do
      begin
        if @PreviewHooks[i] = @CallBack then
        begin
          for j := i to length(PreviewHooks)-2 do
            PreviewHooks[j] := PreviewHooks[j+1];
          setlength(PreviewHooks,length(PreviewHooks)-1);
          result := true;
        end;
      end;
end;



procedure TGraphicLayerManager.RemoveAllPreviewHooks;
begin
  setlength(PreviewHooks,0);
end;




function TGraphicLayerManager.ExecuteLayerSelectionDialog(
      PreselectedLayerID: integer = -1;
      AllowMultiSelection: Boolean = false;
      TabKeyExit: Boolean = false;
      Sender:TObject = nil) : Boolean;
  var
    msg:Tmsg;
    ret, i: integer;
    key: word;
    ckey: char;
    shift: TShiftState;
begin
    if assigned(frm) then
    begin
      MessageBox(frm.Handle,'Layer dialog is alreay in use.'#13#10+
            'No new dialog was started to avoid confusion.',
            'Dialog arleady in use.',
            mb_OK or MB_ICONHAND );
      result := FALSE;
      exit;
    end;

    DialogStarter := Sender;

    // create form
    OnLayerChanges.InsertEvent(UpdateLayerSelectionDialog);

    frm := TLayerSelectDlg.Create(nil, frmDockMode);

    frm.Parent := parent;
    frm.Panel1.Visible := not TabKeyExit;
    frm.SetBounds(self);
    frm.RemoteGLM := self;
    frm.multiselect := AllowMultiSelection;

    if self.LayerByID(PreselectedLayerID) <> -1 then
    begin
      frm.DeselectAll;
      frm.SelectLayer(PreselectedLayerID);
    end;

    result := false;
    self.TerminatedInMessageLoop := false;
    if length(Layers)=0 then exit;

    frm.DlgShow(Sender);

    if TabKeyExit then
    begin
      if GetAsyncKeyState(VK_SHIFT) <> 0 then
        key := VK_LEFT
      else
        key := VK_RIGHT;
      frm.OnKeyDown(self,key,[]);
    end;

    Application.ProcessMessages;

    OnLayerChanges.InsertEvent(frm.LayersChangedNotification);

    repeat

      ret := integer(GetMessage(msg,0,0,0));

      if ret <> 0 then
      begin
        key := msg.wParam;
        ckey := char(key and $FF);
        shift := [];
        // take over some message types...
        if (msg.message = WM_KEYDOWN) then
          begin
            frm.FormKeyDown(nil,key,shift);
            msg.message := 0;
          end
        else if (msg.message = WM_KEYUP) then
          begin
            if (ckey = #9) and TabKeyExit then
            begin
              PostMessage(frm.okbutton.Handle,WM_LBUTTONDOWN,0,0);
              PostMessage(frm.okbutton.Handle,WM_LBUTTONUP,0,0);
            end
            else
            begin
              frm.FormKeyPress(nil,ckey);
              frm.FormKeyUp(nil,key,shift);
            end;
            msg.message := 0;
          end
        else
        begin
          TranslateMessage(msg);
          DispatchMessage(msg);
        end;

      end
      else
      begin
        TerminatedInMessageLoop := true;
        application.Terminate;
        break;
      end;

      if not IsWindowVisible(frm.Handle) then break;

    until frm.isdone;


    if not TerminatedInMessageLoop then
    begin
      result := frm.success;
      try
        OnLayerChanges.RemoveEvent(UpdateLayerSelectionDialog);
        OnLayerChanges.RemoveEvent(frm.LayersChangedNotification);
        frmDockMode := frm.LastDockMode;
      except
      end;

      if (frm.success) and (not frm.multiselect) then
        for i := 0 to length(Layers) -1 do
          if Layers[i].IsSelectedInDialog then
          begin
            _LayerSelectionID := Layers[i].LayerID;
            break;
          end;
      frm.Destroy;
      frm := nil;
      while not windows.PeekMessage(msg,0,0,0,PM_REMOVE) do; // clear message queue
    end;

end;



procedure TGraphicLayerManager.FocusLayer(LayerIndex: longint);
  var
    i: integer;
begin
    if TerminatedInMessageLoop then exit;
    for i := 0 to length(Layers) -1 do
      Layers[i].visible := LayerIndex = i;
    CurrentLayer := LayerIndex;
    if assigned(OnCurrentLayerChange) then OnCurrentLayerChange(self);
    OnLayerChanges.SharedEvent(self);
    ClientPaint(self);
end;



procedure TGraphicLayerManager.UpdateLayerSelectionDialog(Sender:TObject);
begin
  if assigned(frm) then
    frm.LayersChangedNotification(Sender);
end;



procedure TGraphicLayerManager.UpdateMaskLayerUsageInformation;
  var
    i: integer;
    mIdx: integer;
begin
    for i := 0 to length(Layers)-1 do
      Layers[i].UsedAsMaskLayer := false;
    for i := 0 to length(Layers)-1 do
    begin
      mIdx := LayerByID(Layers[i].MaskLayerID);
      if mIdx <> -1 then Layers[mIdx].UsedAsMaskLayer := true;
    end;
end;



function TGraphicLayerManager.SaveLayerToFile(LayerID: longint;
      filename: string; Extension: string): BOOLEAN;
  var
    png: TPNGObject;
    jpg: TJPegImage;
    Layeridx: longint;
  function removechar(s: string; chr: Char): string;
    var i: integer;
    begin
      for i := 1 to length(s) do
        if s[i] <> chr then
          result := result + s[i];
    end;
begin
    result := false;
    LayerIdx := LayerByID(LayerID);
    if LayerIdx = -1 then exit;
    extension := lowercase(removechar(extension,'*'));
    if ExtractFileExt(Filename) ='' then Filename := filename + Extension;

    if extension = '.bmp' then
    begin
      layers[LayerIdx].data.SaveToFile(FileName);
      result := true;
    end;

    if (extension = '.jpg') or (extension = '.jpeg') then
    begin
      jpg := TJPegImage.Create;
      jpg.Assign(layers[LayerIdx].data);
      jpg.CompressionQuality := 100;
      jpg.Smoothing := true;
      jpg.Performance := jpBestQuality;
      jpg.Compress;
      jpg.SaveToFile(FileName);
      jpg.Free;
      result := true;
    end;

    if extension = '.png' then
    begin
      png := TPNGObject.Create;
      png.Assign(self.layers[LayerIdx].data);
      png.SaveToFile(Filename);
      png.Free;
      result := true;
    end;
end;



procedure TGraphicLayerManager.InsertVisualOverlayObject(newobj: TVisualOverlay);
const OBJECT_NOT_FOUND = nil;
begin
  if self.GetVisualOverlayObjectByID(newobj.UID) = OBJECT_NOT_FOUND then
  begin
    setlength(self.VisualOverlays, length( self.VisualOverlays ) + 1);
    // link events
    newobj.ParentRepaint      := self.ClientPaint;
    newobj.ParentLocalRepaint := self.ClientPaintLocally;
    self.VisualOverlays[length( self.VisualOverlays )-1] := newobj; // pass object reference
  end;
end;



function TGraphicLayerManager.RemoveVisualOverlayObject(obj: TVisualOverlay): TVisualOverlay;
var
  i: integer;
begin
  result := nil;
  for i := 0 to length(self.VisualOverlays)-1 do
    if self.VisualOverlays[i] = obj then
    begin
      result := obj;
      self.VisualOverlays[i] := self.VisualOverlays[length(self.VisualOverlays)-1];
      setlength( self.VisualOverlays, length(self.VisualOverlays)-1);
      break;
    end;
end;



function TGraphicLayerManager.RemoveVisualOverlayObject(UID: longint) : TVisualOverlay;
var
  i: integer;
begin
  result := nil;
  for i := 0 to length(self.VisualOverlays)-1 do
    if self.VisualOverlays[i].UID = UID then
    begin
      result := VisualOverlays[i];
      self.VisualOverlays[i] := self.VisualOverlays[length(self.VisualOverlays)-1];
      setlength( self.VisualOverlays, length(self.VisualOverlays)-1);
      break;
    end;
end;



function TGraphicLayerManager.GetVisualOverlayObjectByID(UID: longint): TVisualOverlay;
var
  i: integer;
begin
  result := nil;
  for i := 0 to length(self.VisualOverlays)-1 do
    if self.VisualOverlays[i].UID = UID then
    begin
      result := self.VisualOverlays[i];
      break;
    end;
end;



function TGraphicLayerManager.GetVisualOverlayUIDByPos(pos: TPoint;Shift: TShiftState;
  Button:TMouseButton): longint;
var i: longint;
begin
  result := -1;
  for i := 0 to length(self.VisualOverlays)-1 do
    if VisualOverlays[i].CursorIsInside(Button,Shift,pos) then
    begin
      result := VisualOverlays[i].UID;
      break;
    end;
end;



procedure TGraphicLayerManager.UpdateVisualOverlays(NewScreenArea: TRect);
var
  i : integer;
begin
  for i := 0 to length(self.VisualOverlays)-1 do
    self.VisualOverlays[i].UpdateParentAreaChanges(NewScreenArea);
end;



procedure TGraphicLayerManager.ClientPaintLocally(Sender:TObject);
var
  vo : TVisualOverlayPanel absolute Sender;
  i: integer;
begin
  if (Sender is TVisualOverlayPanel) then
  begin
    for i := 0 to length(self.Layers)-1 do
    begin
      vo.Paint(buffer,self.Origin,self._zoom);
    end;

    BitBlt(
      parent.Canvas.Handle,
      vo.BoundsRect.Left,
      vo.BoundsRect.Top,
      vo.Width,
      vo.Height,
      buffer.Canvas.Handle,
      vo.BoundsRect.Left,
      vo.BoundsRect.Top,
      SRCCOPY);
  end;
end;



procedure TGraphicLayerManager.OnParentMouseDown(Sender: TObject;
    Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  ForwardToOverlay: Boolean;
  i: integer;

begin
  ForwardToOverlay := false;
  self.EventLinkedVisualUID := -1;
  DownEventShiftState := Shift; // shift state is lost once MouseUp occurs!

  for i := length(self.VisualOverlays)-1 downto 0 do // z-order as order of creation
  begin
    if VisualOverlays[i].CursorIsInside(Button,Shift,Point(X,Y)) then
    begin
      EventLinkedVisualUID := VisualOverlays[i].UID;
      ForwardToOverlay := true;
      VisualOverlays[i].MouseDown(Sender,Button,Shift,X,Y);
      break;
    end;
  end;

  // other options that can inhibit Origin movement are appended here
  CanMoveOrigin := (not ForwardToOverlay) and (true);

  if CanMoveOrigin then
  begin
    StartPosition     := Point(X,Y);
    OldOrigin         := self.Origin;
  end;
end;



procedure TGraphicLayerManager.OnParentMouseMove(Sender: TObject;
    Shift: TShiftState; X, Y: Integer);
var
    vo: TVisualOverlay;
    p: TPoint;
const OBJECT_NOT_FOUND = nil;
begin

  // move origin or forward to visual overlay handlers
  if CanMoveOrigin and (ssLeft in Shift) then
  begin
    p.X := OldOrigin.X+(X-StartPosition.X);
    p.Y := OldOrigin.Y+(Y-StartPosition.Y);
    self.Origin := p; // set and repaint
  end
  else
  begin
    if EventLinkedVisualUID <> -1 then
    begin
      vo := self.GetVisualOverlayObjectByID(EventLinkedVisualUID);
      if vo = OBJECT_NOT_FOUND then exit;
      vo.MouseMove(Sender, Shift,X,Y);
    end;
  end;
  
end;



procedure TGraphicLayerManager.OnParentMouseUp(Sender: TObject;
    Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
    vo: TVisualOverlay;
begin
  if assigned(self) then
    if EventLinkedVisualUID <> -1 then
    begin
      self.CanMoveOrigin := false;
      vo := self.GetVisualOverlayObjectByID(EventLinkedVisualUID);
      if not assigned(vo) then exit;
      vo.MouseUp(Sender,Button,Shift,X,Y);
      EventLinkedVisualUID := -1; // drop linking
    end
    else
    begin
      self.CanMoveOrigin := false;
      if ssMiddle in DownEventShiftState then
      begin
        if assigned(self.OnMiddleMouseButtonClick) then
          OnMiddleMouseButtonClick(parent,x,y,DownEventShiftState);
      end;
    end;

end;



procedure TGraphicLayerManager.OnParentMouseWheel(Sender: TObject; Shift: TShiftState;
        WheelDelta: Integer; MousePos: TPoint; var Handled: Boolean);
var
  UID : longint;
  VO : TVisualOverlay;
begin
  MousePos := Point(
          MousePos.X - self.parent.ClientOrigin.X,
          MousePos.Y - self.parent.ClientOrigin.Y);

  UID := self.GetVisualOverlayUIDByPos(MousePos,Shift);
  VO  := self.GetVisualOverlayObjectByID(UID);
  if assigned(VO) then
    if not (VO.HandlesWheelEvents) then UID := -1;

  if (UID <> -1) then
    begin
      VO.MouseWheel(Sender, Shift, WheelDelta, MousePos, Handled);
    end
  else
    begin
      ZoomPoint   := MousePos;
      ZoomByDelta(WheelDelta);
    end;
end;



procedure TGraphicLayerManager.CallExternalEditor(LayerID: Longint; filename: string; paramstring: string);
var
  layeridx: longint;
  path,fn : string;
begin
  layeridx := self.LayerByID(LayerID);
  if layeridx = -1 then exit;

if not ((filename = '$Explorer$') and assigned(self.Layers[layeridx].ExternalEditWatcher)) then
begin

  if assigned(self.Layers[layeridx].ExternalEditWatcher) then
    if MessageBox(0,'The selected Layer maintains an external processing link.'#13#10+
          'Discard link and start new editor?',
          'Layer is already being edited. Restart?',
          MB_YESNO or MB_ICONWARNING) = IDYES
      then
        self.Layers[layeridx].ExternalEditWatcher.Destroy
      else
        exit;

  // create temp folder and save layer
  path := ExtractFilePath(application.ExeName)+COMMON_DATA_PATH;
  if not directoryExists(path) then mkdir(path);
  path := path + '\temp';
  if not directoryExists(path) then mkdir(path);
  path := path + '\'+inttostr(layeridx);
  if not directoryExists(path) then mkdir(path);
  self.SaveLayerToFile(LayerID,path+'\modify','.bmp');
  fn := path+'\modify.bmp';

  // call external editor
  if filename = '' then
    begin
      // open as...
      if not ShellExecuteOpenAs(fn) then exit;
    end
  else
    if filename = '$Explorer$' then
      begin
        // browse...
        ShellExecute(0,'open',PChar(path),nil,nil,SW_SHOWNORMAL);
      end
    else
      begin
        // run editor ...
        if not ShellExecuteOpen(fn,filename) then exit;
      end;

  // create DirectoryWatcher and link event
  self.Layers[layeridx].ExternalEditWatcher :=  TDirectoryWatch.create(
      path,
      FILE_NOTIFY_CHANGE_LAST_WRITE,
      TempFileChangeNotify);
  self.Layers[layeridx].ExternalEditWatcher.longintdata := LayerID;
  self.Layers[layeridx].ExternalEditWatcher.str := fn;
  self.Layers[layeridx].ExternalEditWatcher.Resume;
end
else // re-open folder
begin
  path := ExtractFilePath(application.ExeName)+COMMON_DATA_PATH;
  path := path + '\temp';
  path := path + '\'+inttostr(layeridx);
  ShellExecute(0,'open',PChar(path),nil,nil,SW_SHOWNORMAL);
end;


end;



procedure TGraphicLayerManager.ReleaseExternalEditor(LayerID: Longint);
var
   idx: integer;
   fn: string;
begin
  idx := LayerByID(LayerID);
  if idx = -1 then exit;

  if assigned(Layers[idx].ExternalEditWatcher) then
  begin
    fn := Layers[idx].ExternalEditWatcher.str;
    Layers[idx].ExternalEditWatcher.Destroy;
    Layers[idx].ExternalEditWatcher := nil;
    try
      if FileExists(fn) then
      begin
        DeleteFile(fn);
        rmdir(ExtractFilePath(fn));
      end;
    except
      Application.MessageBox(
          'Cannot remove temporary file(s).',
          'Temporary files cannot be deleted',
          MB_OK);
    end; // try
  end; // if
end;



procedure TGraphicLayerManager.TempFileChangeNotify(Sender:TObject);
var
  layeridx: longint;
  wat: TDirectoryWatch absolute Sender;
begin
  Sleep(200);
  // ask user whether to decline or apply changes or
  // insert changes as a new layer
  if not (Sender is TDirectoryWatch) then exit;
  layeridx := self.LayerByID(wat.longintdata);
  if layeridx = -1 then
    self.NewLayerLoadFromFile(0,0,wat.str)
  else
  begin
    // insert refresher filter here .. allow undo/redo :-)
    // wait for file to be closed and accessible
    // not implemented! leads to access violations! 
    Layers[layeridx].data.LoadFromFile(wat.str);
  end;
  self.OnLayerChanges.SharedEvent(Sender);
  self.ClientPaint(self);
end;



procedure TGraphicLayerManager.ResizeBuffer(BoundsRect: TRect);
var
  new_width, new_height: integer;
begin
  new_width  := abs(BoundsRect.Right - BoundsRect.Left);
  new_height := abs(BoundsRect.Bottom - BoundsRect.Top);
  if new_width  > buffer.Width  then buffer.Width  := new_width  + 128;  // add some excess buffer space to boost performance
  if new_height > buffer.Height then buffer.Height := new_height + 128;
end;



procedure TGraphicLayerManager.OnParentResize(Sender:TObject);
begin
  if assigned(self.frm) then frm.SetBounds(self);
  self.CanMoveOrigin := false; // ResizeBuffer is mandatory when form is resized,
                               // so discard any mouse events that are caused by
                               // double-clicking NC area
  if assigned(Sender) then
  begin
    ResizeBuffer(parent.ClientRect);
    UpdateVisualOverlays(parent.ClientRect);
    ClientPaint(parent);
  end;
end;



procedure TGraphicLayerManager.OnParentKeyPress(Sender:TObject;var Key: Char);
var
  voID: longint;
  vo: TVisualOverlay;
begin

  // global keys
  if key = #27 then
  begin
    self.surpressrepaint;
    self.ZoomFactor := 0.5;
    self.Origin := Point(0,0);
  end;

  // shared
  voID := GetVisualOverlayUIDByPos(zoompoint,[]);
  if voID = -1 then
  begin
    if ZoomMode <> zmFixTo100Percent then
    begin
      if key = #49 then self.ZoomFactor := 0.25;
      if key = #50 then self.ZoomFactor := 0.5;
      if key = #51 then self.ZoomFactor := 1;
      if key = #52 then self.ZoomFactor := 2;
      if key = #53 then self.ZoomFactor := 4;
    end;

    if key = '+' then self.ZoomByDelta(+200); // self.ZoomFactor := self.ZoomFactor*1.1;
    if key = '-' then self.ZoomByDelta(-200); // self.ZoomFactor := self.ZoomFactor/1.1;
  end
  else
  begin
    vo := self.GetVisualOverlayObjectByID(voID);
    vo.KeyPress(Sender, Key);
  end;
end;



procedure TGraphicLayerManager.OnParentKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  voID: longint;
  vo: TVisualOverlay;
begin
  voID := GetVisualOverlayUIDByPos(zoompoint,[]);
  if voID <> -1 then
  begin
    vo := self.GetVisualOverlayObjectByID(voID);
    vo.KeyDown(Sender, Key, Shift);
  end;
end;



procedure TGraphicLayerManager.OnParentKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  voID: longint;
  vo: TVisualOverlay;
begin
  voID := GetVisualOverlayUIDByPos(zoompoint,[]);
  if voID <> -1 then
  begin
    vo := self.GetVisualOverlayObjectByID(voID);
    vo.KeyUp(Sender, Key, Shift);
  end;
end;



function TGraphicLayerManager.TerminateLayerSelectionDialog(Sender:TObject = nil): Boolean; // returns true if dialog had to be terminated
begin
  if assigned(frm) then
  begin
    if Sender = DialogStarter then // privileged action
    begin
      result := frm.Visible;
      frm.isdone := true;
    end
    else
      result := false;
  end
  else
  begin
    result := false;
  end;
end;



procedure TGraphicLayerManager.SetZoomMode(newmode:TGLMZoomMode);
begin
  self._ZoomMode := newmode;

  case newmode of
    zmFixTo100Percent:
      begin
        self._zoom := 1;
        self._pos := Point(0,0);
        self.ClientPaint(nil);
        PostMessage(parent.Handle,WM_USER+$486,0,0); // send WM_UPDATE_FORM_CAPTION
      end;
  end;
end;



procedure TGraphicLayerManager.SetHalftoneMode(newmode:TGLMHalftoneMode);
begin
  if self._HalftoneMode <> newmode then
  begin
    self._HalftoneMode := newmode;
    self.ClientPaint(self);
  end;
end;



procedure TGraphicLayerManager.ZoomByDelta(ticks: longint);
var
  w, idx: integer;
//  ref, diff: single;
begin
  case _ZoomMode of
    zmExponential:
      begin
         ZoomFactor  := ZoomFactor * exp(ln(1.05) * ticks * 0.01);
      end;
    zmPixelwise:
      begin
         w := self.parent.ClientWidth;
         ZoomFactor  := ZoomFactor * exp(ln(1+1/w) * ticks * 0.01);
      end;
    zmLinear:
      begin
         ZoomFactor  := round(ZoomFactor/0.05)*0.05 + round(ticks * 0.01)*0.05;
      end;
    zmPresetSteps:
      begin
        idx := 0;
        for w := 0 to high(ZoomPresetArray) do  // find nearest list element
        begin
          if abs(ZoomPresetArray[w] - Zoomfactor*100) < abs(ZoomPresetArray[idx] - Zoomfactor*100) then
            idx := w;
        end;
        // increment or decrement index to change zoom
        idx := constrain(0,high(ZoomPresetArray),idx+ticks div 100);

        ZoomFactor := ZoomPresetArray[idx]/100;
      end;
    zmFixTo100Percent:
      begin
        // see SetZoomMode ...
      end;
  end;
end;



procedure TGraphicLayerManager.ExecutePresetsDialog(Sender:TObject);
var
  dlg: TMultiFunctionalInputDialog;
  FieldHasChanged: Array[0..15] of Boolean;
var
  iZoomMode: integer;
  iHalftoneMode: integer;
  b: Byte;
  str1: string;
begin
  str1 := 'These are the preferences for GraphicLW that will persist during'#13#10+
          'the ongoing session. You can abort the dialog if you don''t want'#13#10+
          'to apply the changes you made.'#13#10;

  dlg := TMultiFunctionalInputDialog.Create;
  dlg.frm.Caption := 'User Interface Preferences';

  dlg.AddInputField(  'Information about the settings below ...',
                      nil,
                      'info',
                      '',
                      '',
                      str1);

  dlg.AddInputField(  'mouse/keyboard zoom mode',
                      @iZoomMode,
                      'indexcombo',
                      IntToStr(integer(_zoommode)),
                      '',
                      'exponential|pixelwise|linear|preset steps| no zoom (100% view)',
                      @FieldHasChanged[0]);


  dlg.AddInputField(  'screen rendering interpolation',
                      @iHalftoneMode,
                      'indexcombo',
                      IntToStr(integer(_HalftoneMode)),
                      '',
                      'n.n. rendering|halftone',
                      @FieldHasChanged[1]);


  if dlg.Execute then
  begin
    // DO NOT USE THE OBJECT VARIABLE _zoommode
    // because TGLMZoomMode is of type BYTE. Thanks, Delphi...
    b := iZoomMode;
    if FieldHasChanged[0] then self.SetZoomMode(TGLMZoomMode(b));
    b := iHalftoneMode;
    if FieldHasChanged[1] then self.SetHalftoneMode(TGLMHalftoneMode(b));
  end;

  dlg.Destroy;
end;



procedure TGraphicLayerManager.OnParentDblClick(Sender: TObject);
var
  voID: longint;
  vo: TVisualOverlay;
  cur, cl, pt: TPoint;
begin
  cl := parent.ClientOrigin;
  GetCursorPos(cur);
  pt.X := cur.X - cl.X;
  pt.Y := cur.Y - cl.Y;

  voID := GetVisualOverlayUIDByPos(pt,[]);
  if voID <> -1 then
  begin
    vo := self.GetVisualOverlayObjectByID(voID);
    if not vo.HandlesKeyEvents then
    begin
      if assigned(OnDblClick) then OnDblClick(Sender);
    end;
  end
  else if assigned(OnDblClick) then OnDblClick(Sender);
end;

end.
